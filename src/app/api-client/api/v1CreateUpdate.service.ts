/**
 * FastAPI
 *
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpResponse,
  HttpEvent,
  HttpParameterCodec,
  HttpContext,
} from '@angular/common/http';
import { CustomHttpParameterCodec } from '../encoder';
import { Observable } from 'rxjs';

// @ts-ignore
import { HTTPValidationError } from '../model/hTTPValidationError';
// @ts-ignore
import { LegacyBlipRecordInput } from '../model/legacyBlipRecordInput';
// @ts-ignore
import { LegacyBlipRecordOutput } from '../model/legacyBlipRecordOutput';
// @ts-ignore
import { LegacyClipRecordInput } from '../model/legacyClipRecordInput';
// @ts-ignore
import { LegacyClipRecordOutput } from '../model/legacyClipRecordOutput';
// @ts-ignore
import { LegacyCodeformerRecordInput } from '../model/legacyCodeformerRecordInput';
// @ts-ignore
import { LegacyCodeformerRecordOutput } from '../model/legacyCodeformerRecordOutput';
// @ts-ignore
import { LegacyControlnetRecordInput } from '../model/legacyControlnetRecordInput';
// @ts-ignore
import { LegacyControlnetRecordOutput } from '../model/legacyControlnetRecordOutput';
// @ts-ignore
import { LegacyEsrganRecordInput } from '../model/legacyEsrganRecordInput';
// @ts-ignore
import { LegacyEsrganRecordOutput } from '../model/legacyEsrganRecordOutput';
// @ts-ignore
import { LegacyGfpganRecordInput } from '../model/legacyGfpganRecordInput';
// @ts-ignore
import { LegacyGfpganRecordOutput } from '../model/legacyGfpganRecordOutput';
// @ts-ignore
import { LegacyMiscellaneousRecordInput } from '../model/legacyMiscellaneousRecordInput';
// @ts-ignore
import { LegacyMiscellaneousRecordOutput } from '../model/legacyMiscellaneousRecordOutput';
// @ts-ignore
import { LegacySafetyCheckerRecordInput } from '../model/legacySafetyCheckerRecordInput';
// @ts-ignore
import { LegacySafetyCheckerRecordOutput } from '../model/legacySafetyCheckerRecordOutput';
// @ts-ignore
import { LegacyStableDiffusionRecordInput } from '../model/legacyStableDiffusionRecordInput';
// @ts-ignore
import { LegacyTextGenerationRecordInput } from '../model/legacyTextGenerationRecordInput';
// @ts-ignore
import { LegacyTextGenerationRecordOutput } from '../model/legacyTextGenerationRecordOutput';
// @ts-ignore
import { MODEL_REFERENCE_CATEGORY } from '../model/mODELREFERENCECATEGORY';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { BaseService } from '../api.base.service';

@Injectable({
  providedIn: 'root',
})
export class V1CreateUpdateService extends BaseService {
  constructor(
    protected httpClient: HttpClient,
    @Optional() @Inject(BASE_PATH) basePath: string | string[],
    @Optional() configuration?: Configuration,
  ) {
    super(basePath, configuration);
  }

  /**
   * Create a new BLIP model in legacy format
   * Create a new BLIP model in legacy format.  The model name in the request body must not already exist in the blip category.
   * @param legacyBlipRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyBlipRecordOutput>;
  public createLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyBlipRecordOutput>>;
  public createLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyBlipRecordOutput>>;
  public createLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyBlipRecordInput === null || legacyBlipRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyBlipRecordInput was null or undefined when calling createLegacyBlipModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/blip`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyBlipRecordOutput>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyBlipRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Create a new clip model in legacy format
   * Create a new CLIP model in legacy format.  The model name in the request body must not already exist in the clip category.
   * @param legacyClipRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyClipRecordOutput>;
  public createLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyClipRecordOutput>>;
  public createLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyClipRecordOutput>>;
  public createLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyClipRecordInput === null || legacyClipRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyClipRecordInput was null or undefined when calling createLegacyClipModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/clip`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyClipRecordOutput>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyClipRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Create a new Codeformer model in legacy format
   * Create a new Codeformer model in legacy format.  The model name in the request body must not already exist in the codeformer category.
   * @param legacyCodeformerRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyCodeformerRecordOutput>;
  public createLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyCodeformerRecordOutput>>;
  public createLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyCodeformerRecordOutput>>;
  public createLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyCodeformerRecordInput === null || legacyCodeformerRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyCodeformerRecordInput was null or undefined when calling createLegacyCodeformerModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/codeformer`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyCodeformerRecordOutput>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyCodeformerRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Create a new ControlNet model in legacy format
   * Create a new ControlNet model in legacy format.  The model name in the request body must not already exist in the controlnet category.
   * @param legacyControlnetRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyControlnetRecordOutput>;
  public createLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyControlnetRecordOutput>>;
  public createLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyControlnetRecordOutput>>;
  public createLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyControlnetRecordInput === null || legacyControlnetRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyControlnetRecordInput was null or undefined when calling createLegacyControlnetModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/controlnet`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyControlnetRecordOutput>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyControlnetRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Create a new ESRGAN model in legacy format
   * Create a new ESRGAN model in legacy format.  The model name in the request body must not already exist in the esrgan category.
   * @param legacyEsrganRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyEsrganRecordOutput>;
  public createLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyEsrganRecordOutput>>;
  public createLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyEsrganRecordOutput>>;
  public createLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyEsrganRecordInput === null || legacyEsrganRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyEsrganRecordInput was null or undefined when calling createLegacyEsrganModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/esrgan`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyEsrganRecordOutput>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyEsrganRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Create a new GFPGAN model in legacy format
   * Create a new GFPGAN model in legacy format.  The model name in the request body must not already exist in the gfpgan category.
   * @param legacyGfpganRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyGfpganRecordOutput>;
  public createLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyGfpganRecordOutput>>;
  public createLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyGfpganRecordOutput>>;
  public createLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyGfpganRecordInput === null || legacyGfpganRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyGfpganRecordInput was null or undefined when calling createLegacyGfpganModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/gfpgan`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyGfpganRecordOutput>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyGfpganRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Create a new image generation model in legacy format
   * Create a new image generation model in legacy format.  The model name in the request body must not already exist in the image generation category.
   * @param legacyStableDiffusionRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyImageGenerationModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<{ [key: string]: any }>;
  public createLegacyImageGenerationModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<{ [key: string]: any }>>;
  public createLegacyImageGenerationModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<{ [key: string]: any }>>;
  public createLegacyImageGenerationModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (
      legacyStableDiffusionRecordInput === null ||
      legacyStableDiffusionRecordInput === undefined
    ) {
      throw new Error(
        'Required parameter legacyStableDiffusionRecordInput was null or undefined when calling createLegacyImageGenerationModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/image_generation`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<{ [key: string]: any }>('post', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyStableDiffusionRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Create a new miscellaneous model in legacy format
   * Create a new miscellaneous model in legacy format.  The model name in the request body must not already exist in the miscellaneous category.
   * @param legacyMiscellaneousRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyMiscellaneousRecordOutput>;
  public createLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyMiscellaneousRecordOutput>>;
  public createLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyMiscellaneousRecordOutput>>;
  public createLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyMiscellaneousRecordInput === null || legacyMiscellaneousRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyMiscellaneousRecordInput was null or undefined when calling createLegacyMiscellaneousModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/miscellaneous`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyMiscellaneousRecordOutput>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyMiscellaneousRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Create a new safety checker model in legacy format
   * Create a new safety checker model in legacy format.  The model name in the request body must not already exist in the safety_checker category.
   * @param legacySafetyCheckerRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacySafetyCheckerRecordOutput>;
  public createLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacySafetyCheckerRecordOutput>>;
  public createLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacySafetyCheckerRecordOutput>>;
  public createLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacySafetyCheckerRecordInput === null || legacySafetyCheckerRecordInput === undefined) {
      throw new Error(
        'Required parameter legacySafetyCheckerRecordInput was null or undefined when calling createLegacySafetyCheckerModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/safety_checker`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacySafetyCheckerRecordOutput>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacySafetyCheckerRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Create a new text generation model in legacy format
   * Create a new text generation model in legacy format.  The model name in the request body must not already exist in the text generation category.
   * @param legacyTextGenerationRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public createLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyTextGenerationRecordOutput>;
  public createLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyTextGenerationRecordOutput>>;
  public createLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyTextGenerationRecordOutput>>;
  public createLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyTextGenerationRecordInput === null || legacyTextGenerationRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyTextGenerationRecordInput was null or undefined when calling createLegacyTextGenerationModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/text_generation`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyTextGenerationRecordOutput>(
      'post',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyTextGenerationRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Delete a legacy model entry.
   * Delete a model from a legacy model reference category.  Permanently removes the specified model from the category.
   * @param modelCategoryName
   * @param modelName
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public deleteLegacyModel(
    modelCategoryName: MODEL_REFERENCE_CATEGORY,
    modelName: string,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any>;
  public deleteLegacyModel(
    modelCategoryName: MODEL_REFERENCE_CATEGORY,
    modelName: string,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<any>>;
  public deleteLegacyModel(
    modelCategoryName: MODEL_REFERENCE_CATEGORY,
    modelName: string,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<any>>;
  public deleteLegacyModel(
    modelCategoryName: MODEL_REFERENCE_CATEGORY,
    modelName: string,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (modelCategoryName === null || modelCategoryName === undefined) {
      throw new Error(
        'Required parameter modelCategoryName was null or undefined when calling deleteLegacyModel.',
      );
    }
    if (modelName === null || modelName === undefined) {
      throw new Error(
        'Required parameter modelName was null or undefined when calling deleteLegacyModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/${this.configuration.encodeParam({ name: 'modelCategoryName', value: modelCategoryName, in: 'path', style: 'simple', explode: false, dataType: 'MODEL_REFERENCE_CATEGORY', dataFormat: undefined })}/${this.configuration.encodeParam({ name: 'modelName', value: modelName, in: 'path', style: 'simple', explode: false, dataType: 'string', dataFormat: undefined })}`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update an existing BLIP model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyBlipRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyBlipRecordOutput>;
  public updateLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyBlipRecordOutput>>;
  public updateLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyBlipRecordOutput>>;
  public updateLegacyBlipModel(
    legacyBlipRecordInput: LegacyBlipRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyBlipRecordInput === null || legacyBlipRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyBlipRecordInput was null or undefined when calling updateLegacyBlipModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/blip`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyBlipRecordOutput>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyBlipRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update an existing CLIP model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyClipRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyClipRecordOutput>;
  public updateLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyClipRecordOutput>>;
  public updateLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyClipRecordOutput>>;
  public updateLegacyClipModel(
    legacyClipRecordInput: LegacyClipRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyClipRecordInput === null || legacyClipRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyClipRecordInput was null or undefined when calling updateLegacyClipModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/clip`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyClipRecordOutput>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyClipRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update an existing Codeformer model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyCodeformerRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyCodeformerRecordOutput>;
  public updateLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyCodeformerRecordOutput>>;
  public updateLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyCodeformerRecordOutput>>;
  public updateLegacyCodeformerModel(
    legacyCodeformerRecordInput: LegacyCodeformerRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyCodeformerRecordInput === null || legacyCodeformerRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyCodeformerRecordInput was null or undefined when calling updateLegacyCodeformerModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/codeformer`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyCodeformerRecordOutput>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyCodeformerRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Update an existing ControlNet model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyControlnetRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyControlnetRecordOutput>;
  public updateLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyControlnetRecordOutput>>;
  public updateLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyControlnetRecordOutput>>;
  public updateLegacyControlnetModel(
    legacyControlnetRecordInput: LegacyControlnetRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyControlnetRecordInput === null || legacyControlnetRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyControlnetRecordInput was null or undefined when calling updateLegacyControlnetModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/controlnet`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyControlnetRecordOutput>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyControlnetRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Update an existing ESRGAN model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyEsrganRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyEsrganRecordOutput>;
  public updateLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyEsrganRecordOutput>>;
  public updateLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyEsrganRecordOutput>>;
  public updateLegacyEsrganModel(
    legacyEsrganRecordInput: LegacyEsrganRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyEsrganRecordInput === null || legacyEsrganRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyEsrganRecordInput was null or undefined when calling updateLegacyEsrganModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/esrgan`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyEsrganRecordOutput>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyEsrganRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update an existing GFPGAN model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyGfpganRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyGfpganRecordOutput>;
  public updateLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyGfpganRecordOutput>>;
  public updateLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyGfpganRecordOutput>>;
  public updateLegacyGfpganModel(
    legacyGfpganRecordInput: LegacyGfpganRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyGfpganRecordInput === null || legacyGfpganRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyGfpganRecordInput was null or undefined when calling updateLegacyGfpganModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/gfpgan`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyGfpganRecordOutput>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyGfpganRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update an existing miscellaneous model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyMiscellaneousRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyMiscellaneousRecordOutput>;
  public updateLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyMiscellaneousRecordOutput>>;
  public updateLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyMiscellaneousRecordOutput>>;
  public updateLegacyMiscellaneousModel(
    legacyMiscellaneousRecordInput: LegacyMiscellaneousRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyMiscellaneousRecordInput === null || legacyMiscellaneousRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyMiscellaneousRecordInput was null or undefined when calling updateLegacyMiscellaneousModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/miscellaneous`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyMiscellaneousRecordOutput>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyMiscellaneousRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Update an existing model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyStableDiffusionRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<{ [key: string]: any }>;
  public updateLegacyModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<{ [key: string]: any }>>;
  public updateLegacyModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<{ [key: string]: any }>>;
  public updateLegacyModel(
    legacyStableDiffusionRecordInput: LegacyStableDiffusionRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (
      legacyStableDiffusionRecordInput === null ||
      legacyStableDiffusionRecordInput === undefined
    ) {
      throw new Error(
        'Required parameter legacyStableDiffusionRecordInput was null or undefined when calling updateLegacyModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/image_generation`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<{ [key: string]: any }>('put', `${basePath}${localVarPath}`, {
      context: localVarHttpContext,
      body: legacyStableDiffusionRecordInput,
      responseType: <any>responseType_,
      ...(withCredentials ? { withCredentials } : {}),
      headers: localVarHeaders,
      observe: observe,
      transferCache: localVarTransferCache,
      reportProgress: reportProgress,
    });
  }

  /**
   * Update an existing safety checker model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacySafetyCheckerRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacySafetyCheckerRecordOutput>;
  public updateLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacySafetyCheckerRecordOutput>>;
  public updateLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacySafetyCheckerRecordOutput>>;
  public updateLegacySafetyCheckerModel(
    legacySafetyCheckerRecordInput: LegacySafetyCheckerRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacySafetyCheckerRecordInput === null || legacySafetyCheckerRecordInput === undefined) {
      throw new Error(
        'Required parameter legacySafetyCheckerRecordInput was null or undefined when calling updateLegacySafetyCheckerModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/safety_checker`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacySafetyCheckerRecordOutput>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacySafetyCheckerRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }

  /**
   * Update an existing model in legacy format
   * Update an existing model or create if it doesn\&#39;t exist (upsert) in legacy format.  This endpoint is only available when canonical_format&#x3D;\&#39;legacy\&#39; in PRIMARY mode.
   * @param legacyTextGenerationRecordInput
   * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
   * @param reportProgress flag to report request and response progress.
   */
  public updateLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe?: 'body',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<LegacyTextGenerationRecordOutput>;
  public updateLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe?: 'response',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpResponse<LegacyTextGenerationRecordOutput>>;
  public updateLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe?: 'events',
    reportProgress?: boolean,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<HttpEvent<LegacyTextGenerationRecordOutput>>;
  public updateLegacyTextGenerationModel(
    legacyTextGenerationRecordInput: LegacyTextGenerationRecordInput,
    observe: any = 'body',
    reportProgress: boolean = false,
    options?: {
      httpHeaderAccept?: 'application/json';
      context?: HttpContext;
      transferCache?: boolean;
    },
  ): Observable<any> {
    if (legacyTextGenerationRecordInput === null || legacyTextGenerationRecordInput === undefined) {
      throw new Error(
        'Required parameter legacyTextGenerationRecordInput was null or undefined when calling updateLegacyTextGenerationModel.',
      );
    }

    let localVarHeaders = this.defaultHeaders;

    // authentication (APIKeyHeader) required
    localVarHeaders = this.configuration.addCredentialToHeaders(
      'APIKeyHeader',
      'apikey',
      localVarHeaders,
    );

    const localVarHttpHeaderAcceptSelected: string | undefined =
      options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept(['application/json']);
    if (localVarHttpHeaderAcceptSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
    }

    const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

    const localVarTransferCache: boolean = options?.transferCache ?? true;

    // to determine the Content-Type header
    const consumes: string[] = ['application/json'];
    const httpContentTypeSelected: string | undefined =
      this.configuration.selectHeaderContentType(consumes);
    if (httpContentTypeSelected !== undefined) {
      localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
    }

    let responseType_: 'text' | 'json' | 'blob' = 'json';
    if (localVarHttpHeaderAcceptSelected) {
      if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
        responseType_ = 'text';
      } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
        responseType_ = 'json';
      } else {
        responseType_ = 'blob';
      }
    }

    let localVarPath = `/model_references/v1/text_generation`;
    const { basePath, withCredentials } = this.configuration;
    return this.httpClient.request<LegacyTextGenerationRecordOutput>(
      'put',
      `${basePath}${localVarPath}`,
      {
        context: localVarHttpContext,
        body: legacyTextGenerationRecordInput,
        responseType: <any>responseType_,
        ...(withCredentials ? { withCredentials } : {}),
        headers: localVarHeaders,
        observe: observe,
        transferCache: localVarTransferCache,
        reportProgress: reportProgress,
      },
    );
  }
}
